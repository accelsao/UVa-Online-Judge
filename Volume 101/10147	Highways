-------------------------------------------------------------kruskal
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<string>
#include<map>
#include<set>
#include<string>
#include<sstream>
#include<vector>
#include<unordered_map>
using namespace std;

struct point{
	int x, y;
}p[501];
int v[125000];
struct edge{
	int a, b;
	double d;
};
double dis(int i, int j){
	return sqrt((p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y));
}
bool cmp(edge a, edge b){
	return a.d < b.d;
}
int find(int x){
	return v[x] == x ? x : v[x] = find(v[x]);
}
int main(){
	int t;
	cin >> t;
	int n, m;
	while (t--){
		cin >> n;
		for (int i = 0; i < n; i++){
			cin >> p[i].x >> p[i].y;
			v[i] = i;
		}
		cin >> m;
		int a, b;
		for (int i = 0; i < m; i++){
			cin >> a >> b;
			a--, b--;
			a = find(a);
			b = find(b);
			if (a != b)
				v[a] = b;
		}
		vector<edge>e;
		for (int i = 0; i < n - 1; i++)
			for (int j = i + 1; j < n; j++)
				e.push_back(edge{ i, j, dis(i, j) });
		sort(e.begin(), e.end(), cmp);
		int ans = 0;
		for (int i = 0; i < e.size(); i++)
			if (find(e[i].a) != find(e[i].b)){
				v[find(e[i].a)] = find(e[i].b);
				printf("%d %d\n", e[i].a + 1, e[i].b + 1);
				ans++;
			}
		if (!ans)puts("No new highways need");
		if (t)puts("");
	}
}
-------------------------------------------------------------------------------------prim()
#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<string>
#include<map>
#include<set>
#include<string>
#include<sstream>
#include<vector>
#include<functional>
#include<unordered_map>
using namespace std;

struct point{
	int x, y;
}p[801];
double dis(int i, int j){
	return sqrt((p[i].x - p[j].x)*(p[i].x - p[j].x) + (p[i].y - p[j].y)*(p[i].y - p[j].y));
}
struct adj{
	int a;
	double dis;
	//bool operator >(const adj& n)const{ return dis > n.dis; };
};
struct cmp{
	bool operator()(adj a, adj b){
		return a.dis > b.dis;
	}
};
vector<adj>vlist[801];
int n, m;
void prim(){
	int pa[801] = {}, v[801] = {}, ans = 0;
	double d[801] = {};
	for (int i = 1; i <= n; i++)d[i] = 1e9;
	priority_queue<adj, vector<adj>, cmp>pq;
	//priority_queue<adj, vector<adj>, greater<adj>>pq;
	pq.push(adj{ 1, 0 });
	d[1] = 0;
	for (int i = 1; i <= n; i++){
		adj nxt;
		while (v[(nxt = pq.top()).a])pq.pop();
		if (nxt.dis){
			printf("%d %d\n", pa[nxt.a], nxt.a);
			ans++;
		}
		v[nxt.a] = 1;
		//把相鄰且未經過點加入 
		for (int i = 0; i < vlist[nxt.a].size(); i++){
			adj now = vlist[nxt.a][i];
			if (!v[now.a] && now.dis < d[now.a]){
				d[now.a] = now.dis;
				pa[now.a] = nxt.a;
				pq.push(now);
			}
		
		}
	
	}
	if(!ans)
		puts("No new highways need");
}
int main(){
	int t;
	cin >> t;
	while (t--){
		cin >> n;
		for (int i = 1; i <= n; i++){
			cin >> p[i].x >> p[i].y;
			vlist[i].clear();
		}
		for (int i = 1; i <= n; i++)
			for (int j = i + 1; j <= n; j++){
				double d = dis(i, j);
				vlist[i].push_back(adj{ j, d });
				vlist[j].push_back(adj{ i, d });
			}
		int a, b;
		cin >> m;
		while (m--){
			cin >> a >> b;
			vlist[a].push_back(adj{ b, 0 });
			vlist[b].push_back(adj{ a, 0 });
		}
		prim();
		if (t)puts("");
	}
}
