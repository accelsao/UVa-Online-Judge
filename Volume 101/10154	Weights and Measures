---------------------------------------------------------上到下 儲存重量 排序負重
#include <algorithm>  
#include <iostream>  
#include <cstdlib>  
#include <cstdio>  

using namespace std;

struct box{
	int w, s;
}p[6000];

bool cmp(box a, box b)
{
	return a.s < b.s;
}
int dp[6000] = {};
int main(){
	int n = 1;
	while (cin >> p[n].w >> p[n].s)
		n++;
	sort(p + 1,p + n, cmp);
	for (int i = 0; i < n; ++i)
		dp[i] = 1e9;
	dp[0] = 0;

	int Max = 0;
	for (int i = 1; i < n; ++i)
		for (int j = Max + 1; j > 0; --j)
			if (dp[j] > dp[j - 1] + p[i].w && p[i].s > dp[j - 1] + p[i].w) {
				dp[j] = dp[j - 1] + p[i].w;
				if (Max < j) Max = j;
			}
	printf("%d\n", Max);
}
---------------------------------------------------------------------(1)小修改
#include <algorithm>  
#include <iostream>  
#include <cstdlib>  
#include <cstdio>  

using namespace std;

struct box{
	int w, s;
}p[6000];

bool cmp(box a, box b){
	return a.s < b.s;
}
int dp[6000] = {};
int main(){
	int n = 1;
	while (cin >> p[n].w >> p[n].s)
		n++;
	sort(p + 1,p + n, cmp);
	for (int i = 1; i < n; ++i)
		dp[i] = 1e9;
	dp[0] = 0;
	//dp 重量
	int Max = 0;
	for (int i = 1; i < n; ++i)
		for (int j = Max + 1; j > 0; --j)
			if (dp[j - 1]<p[i].s - p[i].w){	
				Max = max(Max, j);
				dp[j] = min(dp[j], dp[j - 1] + p[i].w);
			}
	printf("%d\n", Max);
}
---------------------------------------------------------------------由下到上 儲存負重
#include <algorithm>  
#include <iostream>  
#include <cstdlib>  
#include <cstdio>  

using namespace std;

struct box{
	int w, s;
}p[6000];

bool cmp(box a, box b){
	return a.s > b.s;
}
int dp[6000] = {};
int main(){
	int n = 1;
	while (cin >> p[n].w >> p[n].s)
		n++;
	sort(p + 1, p + n, cmp);
	for (int i = 1; i < n; ++i)
		dp[i] = 0;
	dp[0] = 1e9;
	//dp 負重
	int Max = 0;
	for (int i = 1; i < n; ++i)
		for (int j = Max + 1; j > 0; --j)
			if (dp[j - 1]>p[i].w){
				Max = max(Max, j);
				dp[j] = max(dp[j],min(dp[j - 1]-p[i].w,p[i].s-p[i].w));
				//max(原負重,min(負重-新加的物重=新的負重,新加的物的負重))//加的物負重可能更小
			}
	printf("%d\n", Max);
}
