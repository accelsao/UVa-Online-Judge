#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<string>
#include<map>
#include<set>
#include<string>
#include<sstream>
#include<vector>
#include<functional>
#include<unordered_map>
using namespace std;


struct box {
	int w, s;
	int h;
}p[100000];

bool cmp(box a, box b) {
	if (a.h == b.h)
		return a.s - a.w > b.s - b.w;
	return a.h > b.h;
}
int dp[100005] = {};
int pos[100005][2] = {};
int main() {
	int n = 1;
	while (cin >> p[n].w >> p[n].s >> p[n].h, p[n].w)
		n++;
	sort(p + 1, p + n, cmp);
	for (int i = 1; i < n; ++i)
		for (int j = 0; j < 2; j++)
			dp[i] = 0;
	dp[0] = 1e9;
	//dp 負重
	int Max = 0;
	p[0].h = pos[0][0] = pos[0][1] = 1e9;
	for (int i = 1; i < n; ++i) {
		if (dp[Max] >= p[i].w) {
			Max++;
			for (int i = 1; i <= Max; i++)pos[i][0] = pos[i][1];
		}
		for (int j = Max; j >= 1; j--) {
			if(p[i].h<=pos[j-1][1]&&p[i].h>=pos[j+1][1])
				if (dp[j - 1] >= p[i].w) {
					int k = min(dp[j - 1] - p[i].w, p[i].s - p[i].w);
					if (dp[j] < k) {
						dp[j] = k;
						pos[j][1] = p[i].h;
						break;
					}
					if (dp[j - 1] == p[i].w) {
						dp[j] = k;
						pos[j][1] = p[i].h;
						break;
					}
					//max(原負重,min(負重-新加的物重=新的負重,新加的物的負重))//加的物負重可能更小
				}
		}
	}
	pos[Max][0] = pos[Max][1];
	printf("%d\n", Max);
	int L = pos[1][0] * 2 - 1;//pos[] max 10
	for (int i = Max; i >= 1; i--) {
		int cc = (L - (pos[i][0] * 2 - 1)) / 2;
		while (cc--)putchar(' ');
		for (int j = 0; j < pos[i][0]; j++) {
			if (j)putchar(' ');
			putchar('*');
		}
		cc = (L - (pos[i][0] * 2 - 1)) / 2;
		while (cc--)putchar(' ');
		puts("");
	}
}
