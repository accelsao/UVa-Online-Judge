#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<string>
#include<map>
#include<set>
#include<string>
#include<sstream>
#include<vector>
#include<functional>
#include<unordered_map>
using namespace std;

const int M= 2500 + 10;
struct Ans{
	int ans, px, py, nx, ny;
}s;
vector<int>edge[M];
vector<int>G;
int n, m;
int l[M], r[M];
int dis[M], pre[M], far, bu, bv;
void bfs(int x){
	for (int i = 1; i <= n; i++)dis[i] = -1;
	pre[x] = -1;
	dis[x] = 0;
	queue<int>q;
	q.push(x);
	far = x;
	while (!q.empty()){
		int u = q.front(); q.pop();
		for (int i = 0; i < edge[u].size(); i++){
			int v = edge[u][i];
			if (dis[v] != -1)continue;
			if (min(bu, bv) == min(u, v) && max(bu, bv) == max(u, v))continue;
			dis[v] = dis[u] + 1;
			pre[v] = u;
			q.push(v);
			if (dis[far] < dis[v])far = v;
		}
	}
	G.clear();
	int tmp = far;
	while (tmp != -1){
		G.push_back(tmp);
		tmp = pre[tmp];
	}
}
void work(){
	Ans d = { 0, bu, bv, 0, 0 };
	int link = 1;
	bfs(bu); bfs(far);
	link += (dis[far] + 1) / 2;
	d.nx = G[G.size() / 2];
	d.ans = dis[far];
	bfs(bv); bfs(far);
	d.ny = G[G.size() / 2];
	link += (dis[far] + 1) / 2;
	d.ans = max(d.ans, dis[far]);
	
	d.ans = max(d.ans, link);
	if (d.ans < s.ans)s = d;
}
int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	int t;
	cin >> t;
	while (t--){
		cin >> n;
		for (int i = 0; i <= n; i++)edge[i].clear();
		int a, b;
		for (int i = 1; i < n; i++){
			cin >> a >> b;
			edge[a].push_back(b);
			edge[b].push_back(a);
			l[i] = a, r[i] = b;
		}
		s.ans = 1e9;
		for (int i = 1; i < n; i++){
			bu = l[i], bv = r[i];
			work();
		}
		printf("%d\n%d %d\n%d %d\n", s.ans, s.px, s.py, s.nx, s.ny);
	}
}
