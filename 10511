#include<iostream>
#include<cmath>
#include<algorithm>
#include<cstring>
#include<cstdio>
#include<queue>
#include<string>
#include<map>
#include<set>
#include<string>
#include<sstream>
#include<vector>
#include<functional>
#include<unordered_map>
using namespace std;

const int maxn = 10010;
const int inf = 1 << 30;
struct edge{
	int u, v, next, f;
	edge(int u0 = 0, int v0 = 0, int f0 = 0, int next0 = 0){
		u = u0, v = v0, f = f0, next = next0;
	}
}e[maxn * 10];
int head[maxn * 2], visited[maxn * 2], path[maxn * 2];
int cnt, from, to, marked;
map <int, string> tos;
int nc, np, nd;

void initial(){
	cnt = 0;
	marked = 1;
	memset(head, -1, sizeof(head));
	memset(visited, 0, sizeof(visited));
	tos.clear();
}

void adde(int u, int v, int f){
	e[cnt].u = u, e[cnt].v = v, e[cnt].f = f, e[cnt].next = head[u], head[u] = cnt++;
	e[cnt].u = v, e[cnt].v = u, e[cnt].f = 0, e[cnt].next = head[v], head[v] = cnt++;
}

void input(){
	string st;
	vector <string> v;
	map <string, int> mpc, mpp, mpd;
	map <string, int>::iterator it;
	while (getline(cin, st) && st.length()>0){
		v.push_back(st);
		stringstream ss(st);
		ss >> st;
		mpp[st] = 1;
		ss >> st;
		mpd[st] = 1;
		while (ss >> st) mpc[st] = 1;
	}
	from = 0;
	nc = mpc.size();
	np = mpp.size();
	nd = mpd.size();
	to = nc + np + nd + 1;
	//to num the string  
	it = mpc.begin();
	for (int i = 1; i <= nc; i++){
		adde(from, i, 1);
		it->second = i;
		tos[it->second] = it->first;
		it++;
	}
	it = mpp.begin();
	for (int i = 1; i <= np; i++){
		it->second = nc + i;
		tos[it->second] = it->first;
		it++;
	}
	it = mpd.begin();
	for (int i = 1; i <= nd; i++){
		adde(nc + np + i, to, (nc + 1) / 2 - 1);
		it->second = nc + np + i;
		tos[it->second] = it->first;
		it++;
	}
	for (int i = 0; i<v.size(); i++){
		string name, party, club;
		stringstream ss(v[i]);
		ss >> name >> party;
		adde(mpp[name], mpd[party], 1);
		while (ss >> club){
			adde(mpc[club], mpp[name], 1);
		}
	}
}

bool bfs(){
	int s = from, d;
	queue <int> q;
	q.push(s);
	marked++;
	visited[s] = marked;
	while (!q.empty()){
		s = q.front();
		q.pop();
		for (int i = head[s]; i != -1; i = e[i].next){
			d = e[i].v;
			if (visited[d] != marked && e[i].f>0){
				visited[d] = marked;
				path[d] = i;
				q.push(d);
				if (d == to) return true;
			}
		}
	}
	return false;
}

int maxf(){
	int maxflow = 0;
	while (bfs()){
		int offflow = inf;
		for (int i = to; i != from; i = e[path[i]].u){
			offflow = min(e[path[i]].f, offflow);
		}
		for (int i = to; i != from; i = e[path[i]].u){
			e[path[i]].f -= offflow;
			e[path[i] ^ 1].f += offflow;
		}
		maxflow += offflow;
	}
	return maxflow;
}

void solve(){
	int ans = maxf();
	if (ans >= nc){
		for (int i = 0; i<cnt; i++){
			if (e[i].u >= 1 && e[i].u <= nc && e[i].v >= nc + 1 && e[i].v <= nc + np){
				if (e[i].f <= 0){
					printf("%s %s\n", tos[e[i].v].c_str(), tos[e[i].u].c_str());
				}
			}
		}
	}
	else printf("Impossible.\n");
}

int main(){
	//freopen("in.txt","r",stdin);  
	int t;
	scanf("%d\n", &t);
	while(t--){
		initial();
		input();
		if (t) cout << endl;
		solve();
	}
	return 0;
}*/

/*int T, s, t, mark;
struct edge{
	int u, v, d, nxt;
};
vector<edge>g;
int head[20000], vis[20000],path[20000];
int e;
void add(int u,int v,int d){
	g.push_back(edge{ u, v, d, head[u] }), head[u] = e++;
	g.push_back(edge{ v, u, 0, head[v] }), head[v] = e++;
}
bool bfs(){
	mark++;
	int s = 0, d;
	queue<int>q;
	q.push(s);
	//for (int i = 0; i <= t; i++)vis[i] = 0;
	vis[s] = mark;
	while (!q.empty()){
		s = q.front(); q.pop();
		for (int i = head[s]; i != -1; i = g[i].nxt){
			d = g[i].v;
			if (vis[d] != mark&&g[i].d > 0){
				vis[d] = mark;
				path[d] = i;
				q.push(d);
				if (d == t)return 1;
			}
		}
	}
	return 0;
}
int mf(){
	int ans = 0;
	while (bfs()){
		int flow = 1e9;
		for (int i = t; i != s; i = g[path[i]].u)
			flow = min(flow, g[path[i]].d);
		for (int i = t; i != s; i = g[path[i]].u){
			g[path[i]].d -= flow;
			g[path[i]^1].d += flow;
		}
		ans += flow;
	}
	return ans;
}
vector<string>v;
int main(){
	cin >> T; getchar();
	string str;
	while (T--){
		mark = 1;
		v.clear();
		memset(head, -1, sizeof(head));
		memset(vis, 0, sizeof(vis));
		e = 0;
		map<string, int>party, club, man;
		map <string, int>::iterator it;
		map<int, string>R;
		R.clear();
		while (getline(cin, str)&&str.size()){
			v.push_back(str);
			stringstream ss(str);
			string a, b, c;
			ss >> a; ss >> b;
			man[a] = party[b] = 1;			
			while (ss >> c)
				club[c] = 1;
		}
		s = 0;
		t = party.size() + man.size() + club.size() + 1;

		it = club.begin(); 
		for (int i = 1; i <= club.size(); i++){
			add(s, i, 1);
			it->second = i;
			R[it->second] = it->first;
			it++;
		}
		it = man.begin(); 
		for (int i = 1; i <= man.size(); i++){
			it->second = club.size() + i;
			R[it->second] = it->first;
			it++;
		}
		it = party.begin();
		for (int i = 1; i <= party.size(); i++){
			add(club.size() + man.size() + i, t, (club.size() + 1) / 2 - 1);//流量為俱樂部的不到一半
			it->second = club.size() + man.size() + i;
			R[it->second] = it->first;
			it++;
		}
		for (int i = 0; i < v.size(); i++){
			stringstream ss(v[i]);
			string a, b, c;
			ss >> a >> b;
			add(man[a], party[b], 1);
			while (ss >> c)
				add(club[c], man[a], 1);
		}
		
		int ans = mf();
		if (ans != club.size())
			puts("Impossible.");
		else{
			for (int i = 0; i <e; i++)
				if (g[i].u>=1&&g[i].u<=club.size()&&g[i].v>club.size()&&g[i].v<=club.size()+man.size())
					if (g[i].d == 0){

						cout << R[g[i].v] << ' ' << R[g[i].u] << endl;
					}
		}
		if (T)puts("");
		g.clear();
	}
}*/
