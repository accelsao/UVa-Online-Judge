#include <iostream>
#include<algorithm>
#include<map>
#include<string>
#include<cstdio>
#include<queue>
#include<cmath>
using namespace std;

int m[101][101] = {};
int step[101][101]{};

int find(int x, int y){
	if (step[x][y])return step[x][y];

	step[x][y] = 1;
	//上下左右
	int d[4][2] = { { 0, 1 }, { 0, -1 }, { -1, 0 }, { 1, 0 } };
	for (int i = 0; i < 4;i++)
		if (m[x + d[i][0]][y + d[i][1]] < m[x][y])//可以前進的
			step[x][y] = max(step[x][y], find(x + d[i][0], y + d[i][1]) + 1);//比較原來和其他相鄰位置的step+1(+1是所增加移動的步數)
	return step[x][y];
}

int main(){
	int n;
	cin >> n;
	string s;
	int a, b;
	while (n--){
		cin >> s;
		cin >> a >> b;
		for (int i = 1; i <= a; i++)
			for (int j = 1; j <= b; j++){
				cin >> m[i][j];
				step[i][j] = 0;
			}
		//做邊界
		for (int i = 1; i <= b; i++)
			m[0][i] =m[a+1][i]= 101;
		for (int i = 1; i <= a; i++)
			m[i][0] =m[i][b+1]= 101;
		int ans = 0;
		for (int i = 1; i <= a; i++)
			for (int j = 1; j <= b; j++){
				ans = max(ans, find(i, j));
			}
		cout << s << ": ";
		cout << ans << endl;
	}
}
針對每點dfs 紀錄每點(持續更新的)步數 dp
